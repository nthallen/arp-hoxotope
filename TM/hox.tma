# Flight tma for HOx/H2O
# 09/02/99 Modify gate valve commands for new gate valve.
# 10/12/99 Modify to use beam position monitor in place of GrnP.
# 12/10/99 Modify to check gate valve is open.
# 01/05/00 Change offline position to -450 (was +250).
# 01/11/00 Change algorithm to leave gate valve open - do not drive
#       open or closed
# 01/28/00 Change throttle scan to leave throttle at 2500 for strato
# 01/28/00 4000 for tropo
# 02/22/00 Open gate valve in initialize for safety.
# 07/10/02 Comment out scan in record at 43:55
# 10/30/02 Convert to nanomover for etalon drive.  Comment out all etalon inits
# 11/21/04 Drastically modified for WB-57

%{
  #include <math.h> /* for floor */
  #include "CmdData.h"
  #include "idx64.h"
%}

{ tma_hold((IOSwS & 3) == 1); }
{ depending on (shutdown) {
  } else {
    if ( (IOSwS & 3) == 0 || SW_St == SWS_SHUTDOWN )
      validate shutdown;
  }
}

%{
  int Scan_Mode_Always = 1;
  int Etalon_Scanmode_Requested = 0;
%}

#----------------------------------------------------------------
# Initialize power supplies & set gates
#----------------------------------------------------------------

State initialize {
      > telemetry start
  +1  > fail 0
      # Must cycle power on sols&steppers in case of brown-out
  +1  > power solenoids and steppers off
  +1  > power 28V switched off
  +1  > set etalon online position 30400
  +1  > set etalon online delta 10
  +1  > set etalon offline delta 450
  +1  > set etalon altline delta 910
      # A is fixed, B is adjustable, so to speak.
  +1  > adjGate 1a delay set 75
  +1  > adjGate 1a width set 255
  +1  > adjGate 1b delay set 75
  +1  > adjgate 1b width set 255
  +1  > adjGate 2a delay set 75
  +1  > adjGate 2a width set 255
  +1  > adjGate 2b delay set 0
  +1  > adjgate 2b width set 20
  +1  > power solenoids and steppers on
  +1  Validate Pinch_Valve_Close;
  +1  > Drive etalon in 64000
      Hold until ( EtnSt & 1 ) or 15;
      > Drive etalon out 10000
  +3  > Preset Etalon Position to 24000
  +1  > Drive etalon to 31000
  +1  Hold until ( EtnPs == 31000 ) or 10;
  +3  { double bastep;
        double etstep;
        unsigned short ubastep;
        bastep = 65209 * ((convert(BAPos) - 3.05)/(8.55-3.05));
        if (bastep < 0) bastep = 0;
        else if (bastep > 65535) bastep = 65535;
        ubastep = floor(bastep);
        ci_sendfcmd( 0, "Preset Bellows Position to %u\n",
          ubastep );
	  
        etstep =  convert(EtPos);
	if ( etstep > 20000 && etstep < 40000 ) {
	  ci_sendfcmd(0,"Preset Etalon Position to %.0lf\n",
	    etstep );
	} else msg( 2, "EtPos out of range: %.0lf", etstep );
        Validate instrument_start;
      }
}

#----------------------------------------------------------------
# Initialize lasers, solenoids and drives
#----------------------------------------------------------------

state instrument_start {
      { laser_on_requested = 1; }
  +1  Validate Pinch_Valve_Close;
  +1  > drive attenuator in 6500
  +3  > drive attenuator out 320
  +3  > drive attenuator to 3600
 +14  { if (convert(AtPos)<6.2 || convert(AtPos)>6.4)
          msg(1,"Attenuator zero position out of range");
      }
#     +1  > drive attenuator to 4000

  +5  Validate bellows_eval;
      "Bellows Initialization";

      # BELOW_CLOUDS == off the ground
      depending on (BELOW_CLOUDS) { Validate flight; }
      depending on (ABOVE_CLOUDS) { Validate flight; }
}

#----------------------------------------------------------------
# Turn on laser diodes and peakup.  Only
# accessible after 10 min. run time and off_the ground
# are achieved.
#----------------------------------------------------------------

State flight    {
  depending on (ON_GROUND) { Validate shutdown; }

  +1  > power oh cell on
  +1  > power 28V switched on
      { diodes_on_requested = 1; }
  +1  Hold until valid (laser_diodes_on);
      Validate bellows_eval;
 +55  > Drive etalon to 25000
  +1  > Peakup Off
  +1  > Scan etalon out 10000 by 50
 +60  > Drive etalon in 10000
  +5  > Drive etalon to 28000
  +3  > Peakup On
 +10  > scan etalon out 4000 by 20
      Validate scanning;
}

#----------------------------------------------------------------
#  Scan etalon HO2 at axis 2, OH at axis 1
#----------------------------------------------------------------
State scan  {
      depending on (ON_GROUND) { Validate shutdown; }
      { Etalon_Scanmode_Requested = 0; }
      Hold until valid (Etalon_Hold);
      Hold until valid (laser_diodes_on);
  +1  > topaz diode 1 temperature 26.0 C
  +1  > topaz diode 2 temperature 28.0 C
  +1  > topaz diode 2 temperature 28.0 C
  +1  Hold until valid (laser_diodes_on);
  +1  { if ( convert(DL_TP) < 2.0 ) 
	  ci_sendcmd("Topaz current 17.5 amps\n",0);}
 +10  { if (convert(UVMon) > 5.0)
	  ci_sendcmd("Topaz current 17.0 amps\n",0);}  
  +1  > drive etalon to 31000
  +5  { double Pot_Step, Pot_Diff;
	Pot_Step = convert(EtPos);
	if ( Pot_Step > 20000 && Pot_Step < 40000 ) {
	  Pot_Diff = EtnPs - Pot_Step;
	  if ( Pot_Diff > 500 || Pot_Diff < -500 ) {
	    ci_sendfcmd( 0, "Preset Etalon Position to %.0lf\n",
	      Pot_Step );
	    ci_sendcmd( "Set Etalon Online Position 30500\n", 0 );
	  }
	} msg( 2, "EtPos out of whack: %.0lf", Pot_Step );
      }
  +1  > Drive etalon Online
  +1  > Drive etalon In 500
  +1  > Peakup on
  +1  > Set etalon altline delta 910
  +1  > Scan etalon out 2000 by 5
      Validate scanning;
}

State scanning {
    depending on (ON_GROUND) { Validate shutdown; }
    { if ( EtnSt & 1 ) Validate reset_etalon; }

    Hold until ( EtnFlg == IXFLAG_OFFLINE ) or 300
    else Validate scan_failed;
    Validate record;
}

state scan_failed {
      > Peakup Off
  +3  > Stop Etalon
  +1  > Peakup On
      Validate etalon_defaults;
}

#----------------------------------------------------------------
# Reinitialize the etalon if it ever hits the in limit
#----------------------------------------------------------------
State reset_etalon {
      > Peakup Off
  +3  > Stop Etalon
  +1  > Peakup On
  +1  > Drive etalon in 64000
      Hold until ( EtnSt & 1 ) or 15;
      > Drive etalon out 10000
  +3  > Preset Etalon Position to 24000
  +1  > Drive etalon to 31000
  +1  Hold until ( EtnPs == 31000 ) or 10;
      { double etstep;
        etstep =  convert(EtPos);
	if ( etstep > 20000 && etstep < 40000 ) {
	  ci_sendfcmd(0,"Preset Etalon Position to %.0lf\n",
	    etstep );
	} else msg( 2, "EtPos out of range: %.0lf", etstep );
      }
  +1  Validate etalon_defaults;
}

State etalon_defaults {
      > set etalon online position 30500
      > set etalon altline delta 910
  +1  Validate record;
}

#----------------------------------------------------------------
# Record mode.
#----------------------------------------------------------------
State record {
      depending on (ON_GROUND) { Validate shutdown; }
      depending on (1 Hz) {
        depending on (laser_diodes_on ) {}
        else Validate scan;
      }
      { Etalon_Scanmode_Requested = 1; }

      > SW Status Green Peakup Enable
      Hold until ( SW_St == SWS_TIMEWARP && Scan_Mode_Always )
       or 55:00;
      Validate scan;
}

State standby {
      depending on (ON_GROUND) { Validate shutdown; }
      { Etalon_Scanmode_Requested = 0; }
      Hold until ( SW_St == SWS_TIMEWARP );
      Validate record;
}

State shutdown {
      { diodes_on_requested = 0;
	laser_on_requested = 0;
      }
  +5  > power oh cell off
  +5  > power 28v switched off
  +1  > power oh cell off
# +2  > power solenoids and steppers off
  +5  > telemetry logging suspend
      > Fail 1
  +1  > quit
}

PARTITION
#----------------------------------------------------------------
# PARTITION 2: Etalon data taking
#----------------------------------------------------------------
State Etalon_Hold {
    depending on (1 Hz) {
      if (Etalon_Scanmode_Requested) {
	msg( 0, "Entering Etalon_Scanmode" );
	Validate Etalon_Scanmode;
      }
    }
}

State Etalon_Scanmode NoLog {
    > _Drive Etalon Online
    > _Scan Etalon In 75 by 5
    > _Drive Etalon Offline
    Resume Lab_read;
 +6 > _Drive Etalon Altline
    > _Scan Etalon Out 75 by 5
 +4 Hold until (EtnFlg == 0);
    { if (Etalon_Scanmode_Requested) Validate Etalon_Scanmode;
      else Validate Etalon_Hold;
    }
}

PARTITION
#----------------------------------------------------------------
# PARTITION 3: SW_St control
#----------------------------------------------------------------
# SW_St control
#   Cases handled elsewhere:
#     1-4   Altitude Control
#     12-13 [were Adding_C3F6]
#     20-21 Peakup On/Off (scanning.tma)
#     22    SWS_TIMEWARP Static Value to advance within record
#     23-24 Enable/Disable Green Power Peakup (grnpw.tma peakalgo)
#     25-26 [Auto/Off H2O Lamp]
#     27    Begin Green Power Scan (grnpw.tma)
#----------------------------------------------------------------

State SW_Stat_Wait {
  { int reset_it;
    reset_it = 1;
    switch (SW_St) {
      default:
      case 0: reset_it = 0; break;
      case SWS_SCAN_ALWAYS: Scan_Mode_Always = 1; break;
      case SWS_SCAN_BY_P: Scan_Mode_Always = 0; break;
      case SWS_LASER_ON: laser_on_requested = 1; break;
      case SWS_LASER_OFF: laser_on_requested = 0; break;
      case SWS_DIODES_ON: diodes_on_requested = 1; break;
      case SWS_DIODES_OFF: diodes_on_requested = 0; break;
      case SWS_TIMEWARP: break;
      case SWS_PV_CLOSE: Validate Pinch_Valve_Close; break;
      case SWS_PV_STEPS: Validate Pinch_Valve_Steps_Init; break;
      case SWS_PV_PI: Validate Pinch_Valve_PI_Init; break;
      case SWS_PV_SCAN: Validate Pinch_Valve_Scan; break;
      case SWS_STANDBY: Validate standby; break;
      case SWS_LAB_READ: Validate Lab_read; break;
      case SWS_SHUTDOWN: Validate shutdown; break;
    }
    if (reset_it) Validate SW_Stat_Reset;
  }
}

State SW_Stat_Reset {
  > SW Status Value to 0
  Hold until (SW_St == 0) or 10;
  Validate SW_Stat_wait;
}

PARTITION
#----------------------------------------------------------------
# PARTITION 4: Lab File Input
#----------------------------------------------------------------
# Lab file input
#----------------------------------------------------------------

State Lab_idle {
}
State Lab_read "hoxp.tmas" {
  Validate Lab_idle;
}

PARTITION
#----------------------------------------------------------------
# PARTITION 5: Bellows
#----------------------------------------------------------------
# Bellows evaluation.  Set Dye_P_Low/High for max online power.
# Drives bellows up or down until DLH_P is within range.  
#----------------------------------------------------------------


%{ /* Bellows constants. Dye_P_Low/High are specified here as
        Volts times a conversion factor.
    */
  AD12_uGg Dye_P_Low  = (AD12_uGg) (5.15 * .1 * 65536.);
  AD12_uGg Dye_P_High = (AD12_uGg) (5.15 * .1 * 65536.);
  IndxrPos Bellows_Drive_Low = 5000;
  IndxrPos Bellows_Drive_High = 61000;
%}
State bellows_idle { }
State bellows_eval {
  { if (DLH_P < Dye_P_Low) {
      msg(0, "Dye laser needs to be pumped up");
      validate bellows_pump_up;
    } else if (DLH_P    > Dye_P_High) {
      msg(0, "Dye laser needs to be pumped out");
      validate bellows_pump_out;
    } else {
      msg(0, "Dye laser pressure within proper range");
      validate bellows_idle;
    }
  }
}
State bellows_pump_up {
      > Drive bellows out 1000
  +2  { if (DLH_P >= Dye_P_Low) {
	  msg(0, "Dye laser pumped up");
	  validate bellows_idle;
	} else if (BlwPs > Bellows_Drive_High) {
	  msg(2, "Bellows out of drive range during pump-up");
	  validate bellows_idle;
	} else validate bellows_pump_up;
      }
}
State bellows_pump_out {
      > Drive bellows in 1000
  +2  { if (DLH_P <= Dye_P_High) {
	  msg(0, "Dye laser pumped out");
	  validate bellows_idle;
	} else if (BlwPs < Bellows_Drive_Low) {
	  msg(2, "Bellows out of drive range during pump-out");
	  validate bellows_idle;
	} else validate bellows_pump_out;
      }
}

PARTITION
#----------------------------------------------------------------
# PARTITION 6: Altitude
#----------------------------------------------------------------
#   This partition converts pressure (altitude) into states (ON_GROUND,
#   BELOW_CLOUDS, ABOVE_CLOUDS). The threshold pressures each have two
#   values - one for the flight up and the other for the flight down.
#   This provides hysteresis and prevents bouncing.  
#----------------------------------------------------------------

%{ /* Altitude definitions */
    TORR P_ground_up = 580.;
    TORR P_ground_dn = 650.;
    TORR P_clouds_up = 350.;
    TORR P_clouds_dn = 500.;
    int using_swp = 0;
%}

# note on 960718 it was 10 min to below the clouds 
# and +7 min to above the clouds

State ON_GROUND {
    { using_swp = 0; }
    { if ( SW_St == 1 ) {
        using_swp = 1;
        Validate SW_Stat_Reset;
      }
      if (using_swp || (convert(PaltP) < P_ground_up))
        Validate BELOW_CLOUDS;
    }
}

State BELOW_CLOUDS {
    { if ( using_swp && ( SW_St == 2 || SW_St == 4 ) )
        Validate SW_Stat_Reset;
      if ((using_swp && SW_St == 2) ||
          (!using_swp && convert(PaltP) < P_clouds_up)) {
        Validate ABOVE_CLOUDS;
      } else if ((using_swp && SW_St == 4) ||
                 (!using_swp && convert(PaltP) > P_ground_dn)) {
        Validate ON_GROUND;
      }
    }
}

State ABOVE_CLOUDS {
    { if ( using_swp && SW_St == 3 )
        Validate SW_Stat_Reset;
      if ( (using_swp && SW_St == 3) ||
          (!using_swp && convert(PaltP) > P_clouds_dn))
        Validate BELOW_CLOUDS;
    }
}
