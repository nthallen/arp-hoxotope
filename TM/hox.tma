# Flight tma for HOx/H2O
# 09/02/99 Modify gate valve commands for new gate valve.
# 10/12/99 Modify to use beam position monitor in place of GrnP.
# 12/10/99 Modify to check gate valve is open.
# 01/05/00 Change offline position to -450 (was +250).
# 01/11/00 Change algorithm to leave gate valve open - do not drive
#       open or closed
# 01/28/00 Change throttle scan to leave throttle at 2500 for strato
# 01/28/00 4000 for tropo
# 02/22/00 Open gate valve in initialize for safety.
# 07/10/02 Comment out scan in record at 43:55
# 10/30/02 Convert to nanomover for etalon drive.  Comment out all etalon inits
# 11/21/04 Drastically modified for WB-57

%{
  #include <math.h> /* for floor */
  #include "CmdData.h"
  int saw_cruise = 0;
%}

{ tma_hold((IOSwS & 3) == 1); }
{ depending on (shutdown) {
  } else {
    if ( (IOSwS & 3) == 0 || SW_St == 255 ||
         ( saw_cruise && convert(SD__P) > 700.0 ) )
      validate shutdown;
  }
}

#{ if ( convert(SD__P) < 150 ) saw_cruise = 1; }

%{
  int Scan_Mode_Always = 0;
%}

# Review use of valve_open state: appears to be automatic and
# totally defined, yet there are several commands which attempt
# to define it...
#----------------------------------------------------------------

# Initialize power supplies & set gates
#----------------------------------------------------------------

State initialize {
      > telemetry start
  +1  > fail 0
  +1  > PsD select dye laser
  +1  > power solenoids and steppers off
  +1  > power 28V switched off
  +1  > set etalon online position 30400
  +1  > set etalon online delta 10
  +1  > set etalon offline delta 450
  +1  > set etalon altline delta 950
      # A is fixed, B is adjustable, so to speak.
  +1  > adjGate 1a delay set 120
  +1  > adjGate 1a width set 255
  +1  > adjGate 1b delay set 120
  +1  > adjgate 1b width set 255
  +1  > adjGate 2a delay set 150
  +1  > adjGate 2a width set 255
  +1  > adjGate 2b delay set 0
  +1  > adjgate 2b width set 20
  +1  > power solenoids and steppers on
  +3  { double bastep;
        double etstep;
        unsigned short ubastep;
        unsigned short uetstep;
        bastep = 65209 * ((convert(BAPos) - 3.05)/(8.55-3.05));
        if (bastep < 0) bastep = 0;
        else if (bastep > 65535) bastep = 65535;
        ubastep = floor(bastep);
        ci_sendfcmd( 0, "Preset Bellows Position to %u\n",
          ubastep );
        etstep =  30000 - (convert(EtPos) - 4.91)*14285;
        if (etstep < 0) etstep = 0;
        else if (etstep > 65535) etstep = 65535;
        uetstep = floor(etstep);
        ci_sendfcmd(0,"Preset Etalon Position to %u\n",
          uetstep );  
        Validate instrument_start;
      }
}

#----------------------------------------------------------------

# Initialize lasers, solenoids and drives                      #
#----------------------------------------------------------------

state instrument_start {
      { laser_on_requested = 1; }
  +1  Validate Pinch_Valve_Close;
  +1  > drive attenuator in 6500
  +3  > drive attenuator out 320
  +3  > drive attenuator to 3600
 +14  { if (convert(AtPos)<6.2 || convert(AtPos)>6.4)
          msg(1,"Attenuator zero position out of range");
      }
#     +1  > drive attenuator to 4000

# Validate etalon_init.  One init cycle takes 27 seconds, maximum
# 3 cycles.  Do not issue etalon commands for 90 seconds after
# calling etalon_init.  Call etalon_sit to make sure the initialization
# is disabled after 2 minutes.
#
#       +5  Validate etalon_init;
#           "Etalon Initialization";
#    +2:00  Validate etalon_sit;
  +5  Validate bellows_eval;
      "Bellows Initialization";
      depending on (BELOW_CLOUDS) { Validate flight; }
      depending on (ABOVE_CLOUDS) { Validate flight; }
}

#----------------------------------------------------------------

# Turn on laser diodes and peakup.  Only
# accessible after 10 min. run time and off_the ground
# are achieved.
#----------------------------------------------------------------

State flight    {
        depending on (ON_GROUND) { Validate shutdown; }

        +1  > power oh cell on
        +1  > power 28V switched on
            { diodes_on_requested = 1; }
        +1  Hold until valid (laser_diodes_on);
            Validate bellows_eval;
#      +55  > scan etalon out 45000 by 200
#      +60  > Drive etalon in 10000
#       +5  > Drive etalon to 28000
#       +3  > Peakup On
#      +10  > scan etalon out 4000 by 20
#     +300  > Peakup Off
#       +3  > Stop Etalon
#       +1  > Peakup On
        +1  > set etalon online delta 5
#       +1  > soldrv select mode 0
        +1  > SW Status Green Peakup Enable
       +90  Validate limbo;
}
 
#----------------------------------------------------------------
# Limbo.  Intermediate state between off_the_ground
# and above_the_clouds for record, and between
# below_the_clouds and on_the ground for shutdown.
#----------------------------------------------------------------

State limbo {
  depending on (ABOVE_CLOUDS) { Validate record; }
  depending on (ON_GROUND) { Validate shutdown; }
}

#----------------------------------------------------------------

# Record mode. Accessible from limbo.
#----------------------------------------------------------------

State record NoLog  {
      depending on (BELOW_CLOUDS) { Validate purgatory; }
      depending on (ON_GROUND) { Validate purgatory; }
      depending on (1 Hz) {
        depending on (laser_diodes_on ) {}
        else Validate scan;
      }
      > Drive Etalon Online
      > Scan Etalon In 75 by 5
      > Drive Etalon Offline
      Resume Lab_read;
  +6  > Drive Etalon Altline
      > Scan Etalon Out 75 by 5
  +4  Hold until (EtnFlg == 0);
      Validate record;
}

#----------------------------------------------------------------
# State add_c3f6 at front axis.  Make sure c3f6 addition
# is complete before closing gate valve in state scan.
# Use 350 torr in the troposphere.
#----------------------------------------------------------------
State add_c3f6  {
            depending on (BELOW_CLOUDS) { Validate purgatory; }
            depending on (ON_GROUND) { Validate purgatory; }
            depending on (1 Hz) {
              depending on (laser_diodes_on ) {}
              else Validate scan;
            }
#       +1  Validate throttle_medium;
#       +2  > soldrv select mode 9
#      +33  Validate throttle_fast;
#      +30  > soldrv select mode 4
        +6  { if (convert(SD__P) < 350. || Scan_Mode_Always)
                Validate scan;
              else Validate record; }
}

#----------------------------------------------------------------
#  Scan etalon HO2 at axis 2, OH at axis 1
#
#  Make sure that scan is longer than throttle_scan !!!!!!
# Check EtPos vs EtnPs at the beginning of scan.
# 04/17/97 EtPos = 3.51 at EtnPs = 29000.
# 09/04/97  EtPos = 3.52 at EtnPs = 26650.
# 09/25/97 EtPos = 3.45 at EtnPs = 30000.
# 02/03/99  EtPos = 3.92 at EtnPs = 25560.
# 10/05/99 EtPos = 3.20 at EtnPs = 29650
# 03/13/00 EtPos = 2.72 at EtnPs = 29600
# 07/26/01 EtPos =2.87 at EtnPs = 32000
# 07/09/02 EtPos = 3.08 at EtnPs = 36700
#----------------------------------------------------------------
State scan  {
            depending on (BELOW_CLOUDS) { Validate purgatory; }
            depending on (ON_GROUND) { Validate purgatory; }
            Hold until valid (laser_diodes_on);
#       +1  Validate valve_close;   
#       +1  Validate throttle_scan; 
#      +10  > soldrv select mode 0 
#      +20  Validate valve_open;    
#  we now do some stuff to check laser performance
        +1  > topaz diode 1 temperature 26.0 C
        +1  > topaz diode 2 temperature 27.0 C
        +1  > topaz diode 2 temperature 27.0 C
        +1  Hold until valid (laser_diodes_on);
        +1  { if (DL_TP < 6500) 
                ci_sendcmd("Topaz current 17.5 amps\n",0);}
       +10  { if (convert(UVMon) > 5.0)
                ci_sendcmd("Topaz current 17.0 amps\n",0);}  
        +1  > drive etalon to 36700
        +5  { if (convert(EtPos) > 3.40 || convert(EtPos) < 2.80)
                Validate etalon_init;
            }
        +2  Hold until valid (etalon_sit);
        +1  > Drive Etalon to 29000
        +1  > Peakup on
        +1  > set etalon online delta 20
        +1  > scan etalon out 3000 by 10
# Make sure scan is longer than throttle scan (3 minutes min.)!
# Make sure there is enough time to find the line.
      +180  > peakup off
        +3  > stop etalon
        +1  > peakup on
        +1  > set etalon online delta 10
        +1  > drive attenuator to 4000
        +2  Validate record;
}

#----------------------------------------------------------------

# Purgatory.  Prepare system for limbo and either record or shutdown
#----------------------------------------------------------------


State purgatory {
        +1  > peakup off
        +1  > stop etalon
#       +1  > soldrv select mode 4
#       +5  Validate throttle_shut;
        +13 > peakup on
            Validate limbo;
}

#----------------------------------------------------------------

# shutdown.  Accessible from Limbo.
#----------------------------------------------------------------


State shutdown {
#       +1  > soldrv select mode 0
#       +2  > soldrv select mode 4
#       +1  Validate throttle_shut;
            { diodes_on_requested = 0;
              laser_on_requested = 0;
            }
        +5  > power oh cell off
        +5  > power 28v switched off
#       +1  Validate valve_close;
        +1  > power oh cell off
        +2  > power solenoids and steppers off
        +5  > telemetry logging suspend
            > Fail 1
        +1  > quit
}

PARTITION
# PARTITION 2: SW_St control
#----------------------------------------------------------------

# SW_St control
#   Cases handled elsewhere:
#     1-4   Altitude Control
#     12-13 [were Adding_C3F6]
#     20-21 Peakup On/Off (scanning.tma)
#     22    SWS_TIMEWARP Static Value to advance within record
#     23-24 Enable/Disable Green Power Peakup (grnpw.tma peakalgo)
#     25-26 [Auto/Off H2O Lamp]
#     27    Begin Green Power Scan (grnpw.tma)
#----------------------------------------------------------------

State SW_Stat_Wait {
  { int reset_it;
    reset_it = 1;
    switch (SW_St) {
      default:
      case 0: reset_it = 0; break;
      case SWS_SCAN_ALWAYS: Scan_Mode_Always = 1; break;
      case SWS_SCAN_BY_P: Scan_Mode_Always = 0; break;
      case SWS_LASER_ON: laser_on_requested = 1; break;
      case SWS_LASER_OFF: laser_on_requested = 0; break;
      case SWS_DIODES_ON: diodes_on_requested = 1; break;
      case SWS_DIODES_OFF: diodes_on_requested = 0; break;
      case SWS_TIMEWARP: break;
      case SWS_PV_CLOSE: Validate Pinch_Valve_Close; break;
      case SWS_PV_STEPS: Validate Pinch_Valve_Steps_Init; break;
      case SWS_PV_PI: Validate Pinch_Valve_PI_Init; break;
      case SWS_LAB_READ: Validate Lab_read; break;
      case SWS_SHUTDOWN: Validate shutdown; break;
    }
    if (reset_it) Validate SW_Stat_Reset;
  }
}

State SW_Stat_Reset {
  > SW Status Value to 0
  Hold until (SW_St == 0) or 10;
  Validate SW_Stat_wait;
}

PARTITION
# PARTITION 3: Lab File Input
#----------------------------------------------------------------

# Lab file input
#----------------------------------------------------------------

State Lab_idle {
}
State Lab_read "hoxp.tmas" {
  Validate Lab_idle;
}

PARTITION
# PARTITION 4: Bellows
#----------------------------------------------------------------

# Bellows evaluation.  Set Dye_P_Low/High for max online power.
# Drives bellows up or down until DLH_P is within range.  
#----------------------------------------------------------------


%{ /* Bellows constants. Dye_P_Low/High are specified here as
        Volts times a conversion factor.
    */
  AD12_uGg Dye_P_Low  = (AD12_uGg) (5.05 * .1 * 65536.);
  AD12_uGg Dye_P_High = (AD12_uGg) (5.05 * .1 * 65536.);
  IndxrPos Bellows_Drive_Low = 5000;
  IndxrPos Bellows_Drive_High = 61000;
%}
State bellows_idle { }
State bellows_eval {
  { if (DLH_P < Dye_P_Low) {
      msg(0, "Dye laser needs to be pumped up");
      validate bellows_pump_up;
    } else if (DLH_P    > Dye_P_High) {
      msg(0, "Dye laser needs to be pumped out");
      validate bellows_pump_out;
    } else {
      msg(0, "Dye laser pressure within proper range");
      validate bellows_idle;
    }
  }
}
State bellows_pump_up {
      > Drive bellows out 1000
  +2  { if (DLH_P >= Dye_P_Low) {
	  msg(0, "Dye laser pumped up");
	  validate bellows_idle;
	} else if (BlwPs > Bellows_Drive_High) {
	  msg(2, "Bellows out of drive range during pump-up");
	  validate bellows_idle;
	} else validate bellows_pump_up;
      }
}
State bellows_pump_out {
      > Drive bellows in 1000
  +2  { if (DLH_P <= Dye_P_High) {
	  msg(0, "Dye laser pumped out");
	  validate bellows_idle;
	} else if (BlwPs < Bellows_Drive_Low) {
	  msg(2, "Bellows out of drive range during pump-out");
	  validate bellows_idle;
	} else validate bellows_pump_out;
      }
}

PARTITION
# PARTITION 5: Altitude
#----------------------------------------------------------------

#----------------------------------------------------------------

#   This partition converts pressure (altitude) into states (ON_GROUND,
#   BELOW_CLOUDS, ABOVE_CLOUDS). The threshold pressures each have two
#   values - one for the flight up and the other for the flight down.
#   This provides hysteresis and prevents bouncing.  
#----------------------------------------------------------------

#----------------------------------------------------------------


%{ /* Altitude definitions */
    AD12 P_ground_up = (AD12) (580. * .001 * 65536.);
    AD12 P_ground_dn = (AD12) (650. * .001 * 65536.);
    AD12 P_clouds_up = (AD12) (350. * .001 * 65536.);
    AD12 P_clouds_dn = (AD12) (500. * .001 * 65536.);
    int using_swp = 0;
%}

# note on 960718 it was 10 min to below the clouds 
# and +7 min to above the clouds

State ON_GROUND {
    { using_swp = 0; }
    { if ( SW_St == 1 ) {
        using_swp = 1;
        Validate SW_Stat_Reset;
      }
      if (using_swp || (SD__P < P_ground_up))
        Validate BELOW_CLOUDS;
    }
}

State BELOW_CLOUDS {
    { if ( using_swp && ( SW_St == 2 || SW_St == 4 ) )
        Validate SW_Stat_Reset;
      if ((using_swp && SW_St == 2) ||
          (!using_swp && SD__P < P_clouds_up)) {
        Validate ABOVE_CLOUDS;
      } else if ((using_swp && SW_St == 4) ||
                 (!using_swp && SD__P > P_ground_dn)) {
        Validate ON_GROUND;
      }
    }
}

State ABOVE_CLOUDS {
    { if ( using_swp && SW_St == 3 )
        Validate SW_Stat_Reset;
      if ( (using_swp && SW_St == 3) ||
          (!using_swp && SD__P > P_clouds_dn))
        Validate BELOW_CLOUDS;
    }
}

PARTITION
# PARTITION 8: Etalon
#----------------------------------------------------------------

# Partition to initialize the etalon.  Set init_limit to the
# number of initialization attempts.  Make sure there is enough
# time in Initialize.  Set voltages for the etalon at 15,000 to
# control initialization attempts.
#----------------------------------------------------------------

%{
  static int init_count=0, init_limit=3;
%}

state etalon_sit    {   }

state etalon_init   {
        +1  > drive etalon out 10000
        +5  > drive etalon in 65000
        +5  > drive etalon in 65000
        +5  > drive etalon out 6400
        +5  { if ((EtnPs < 3900) || (EtnPs > 5600)) {
                int zero_pos;
                zero_pos=EtnPs;
                msg(1,"Etalon zero position out of range EtnPs=%d",zero_pos);
              }
            }
        +5  > drive etalon to 15000
#
# 04/26/97 etalon_pos at 15,000 is 4.57 V.  Set range to +/- 1000 steps
# 06/14/99 etalon_pos at 15,000 is 4.53 V.
# 03/13/00 etalon_pos at 15,000 is 4.06 V
# 02/22.01 etalon_pos at 15,000 is 4.42 V
# 07/09/02 etalon_pos at 15,000 is 5.57 V
#
        +5  { if ((EtPos<(5.00*.1*65536)) || (EtPos>(6.00*.1*65536))) {
                float etalon_pos;
                etalon_pos=EtPos;
                etalon_pos=(etalon_pos*10)/65536;
                msg(1,"Etalon voltage out of range EtPos=%f",etalon_pos);
                if (++init_count < init_limit) validate etalon_init;
                else validate etalon_sit;
              }
            }
        +1  Validate etalon_sit;
}

#----------------------------------------------------------------
